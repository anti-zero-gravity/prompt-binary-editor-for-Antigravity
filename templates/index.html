<!DOCTYPE html>
<!--
  Binary Prompt Editor — フロントエンドUI

  キーバインド:
    Delete:  選択範囲を0x20(スペース)で埋める
    Ctrl+Z:  直前の編集操作を元に戻す
    Ctrl+Shift+Z / Ctrl+Y: やり直し
    Ctrl+Enter: 検索実行 / 次の候補
    Ctrl+Shift+Enter: 前の候補 (循環)
-->
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Prompt Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: #333;
            padding: 8px 16px;
            border-bottom: 1px solid #555;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        header h1 {
            font-size: 14px;
            color: #4ec9b0;
        }

        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .panel-top {
            border-bottom: 2px solid #4ec9b0;
        }

        /* --- 履歴パネル --- */
        .history-panel {
            width: 340px;
            min-width: 200px;
            background: #1a1a2e;
            border-right: 2px solid #4ec9b0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .history-panel .panel-header {
            flex-shrink: 0;
        }

        .history-list {
            flex: 1;
            overflow-y: auto;
            padding: 4px;
            font-size: 12px;
        }

        .history-entry {
            padding: 4px 8px;
            border-bottom: 1px solid #2d2d3e;
            line-height: 1.5;
            cursor: pointer;
        }

        .history-entry:hover {
            background: #2a2d3e;
        }

        .history-entry .h-line {
            color: #569cd6;
            font-weight: bold;
        }

        .history-entry .h-action {
            color: #4ec9b0;
        }

        .history-entry .h-action.del {
            color: #f14c4c;
        }

        .history-entry .h-addr {
            color: #ce9178;
        }

        .history-entry .h-time {
            color: #808080;
            font-size: 11px;
        }

        .history-entry.undone {
            text-decoration: line-through;
            opacity: 0.45;
        }

        .history-entry .h-saved {
            float: right;
            color: #4ec9b0;
            font-size: 10px;
            font-weight: bold;
            margin-left: 8px;
        }

        .history-entry .h-unsaved {
            float: right;
            color: #ffffff;
            font-size: 10px;
            font-weight: bold;
            margin-left: 8px;
        }

        /* --- 辞書パネル --- */
        .dict-panel {
            width: 115px;
            min-width: 100px;
            background: #1a1a2e;
            border-right: 2px solid #4ec9b0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .dict-panel .panel-header {
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .reload-btn {
            background: #4ec9b0;
            color: #000;
            border: none;
            padding: 3px 8px;
            font-size: 10px;
            cursor: pointer;
            border-radius: 3px;
            font-family: inherit;
            transition: background 0.2s, color 0.2s;
            font-weight: bold;
        }

        .reload-btn:hover {
            background: #3eb099;
        }

        .reload-btn.dirty {
            background: #e74c3c;
            color: #fff;
            animation: blink-text 1s ease-in-out infinite;
        }

        .reload-btn.dirty:hover {
            background: #c0392b;
            animation: none;
            color: #fff;
        }

        @keyframes blink-text {

            0%,
            100% {
                color: #fff;
            }

            50% {
                color: rgba(255, 255, 255, 0.2);
            }
        }

        @keyframes blink-save {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        .dict-content {
            flex: 1;
            padding: 4px 6px;
            font-size: 12px;
            line-height: 1.6;
            overflow: hidden;
        }

        .dict-editor-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            background: #1e1e1e;
        }

        .dict-overlay,
        .dict-source {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 4px 6px;
            border: none;
            box-sizing: border-box;
            font-family: Consolas, 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.6;
            white-space: pre;
            overflow-wrap: break-word;
            overflow: hidden;
        }

        .dict-source {
            color: transparent !important;
            background: transparent !important;
            caret-color: #00bfff;
            resize: none;
            overflow: auto;
            z-index: 2;
        }

        .dict-overlay {
            pointer-events: none;
            z-index: 1;
            color: #d4d4d4;
        }

        .space-mark {
            background-color: #665c00;
            color: #00bfff;
        }

        /* --- Hexダンプエリア --- */
        .hex-area {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .panel-middle {
            background: #252526;
            padding: 8px 16px;
            border-bottom: 2px solid #4ec9b0;
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 0 0 auto;
        }

        .search-box {
            flex: 1;
            background: #3c3c3c;
            border: 1px solid #555;
            color: #d4d4d4;
            padding: 8px 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            resize: vertical;
            min-height: 40px;
            max-height: 120px;
            border-radius: 2px;
            outline: none;
        }

        .search-box:focus {
            border-color: #4ec9b0;
        }

        .search-btn {
            background: #4ec9b0;
            color: #1e1e1e;
            border: none;
            padding: 10px;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .search-btn:hover {
            background: #3eb099;
        }

        .search-btn svg {
            width: 20px;
            height: 20px;
        }

        .header-right-group {
            display: flex;
            align-items: center;
        }

        .header-btn {
            background: #3c3c3c;
            color: #d4d4d4;
            border: 1px solid #555;
            padding: 2px 8px;
            font-size: 11px;
            cursor: pointer;
            border-radius: 3px;
            transition: background 0.2s;
            white-space: nowrap;
        }

        .header-btn:hover {
            background: #555;
        }

        .clickable-filename {
            background-color: #4ec9b0;
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.2s;
            white-space: nowrap;
        }

        .clickable-filename:hover {
            background-color: #3eb099;
        }

        #edit-button {
            background: #f39c12;
        }

        #edit-button:hover {
            background: #d68910;
        }

        .panel-content {
            flex: 1;
            overflow: auto;
            padding: 8px;
        }

        .panel-header {
            background: #252526;
            padding: 4px 8px;
            margin-bottom: 8px;
            border-left: 3px solid #4ec9b0;
            font-size: 12px;
            color: #808080;
        }

        /* ミニマップ */
        .minimap-wrapper {
            width: 80px;
            position: relative;
            background: #252526;
            border: 1px solid #3c3c3c;
            border-left: 3px solid #252526;
        }

        .minimap-wrapper.focused {
            border-left: 3px solid #4ec9b0;
        }

        .minimap-container {
            width: 100%;
            height: 100%;
            overflow-y: scroll;
            overflow-x: hidden;
            outline: none;
        }

        .minimap-container canvas {
            display: block;
            width: 100%;
        }

        .minimap-padding {
            width: 100%;
            background: #252526;
        }

        .minimap-cursor {
            position: absolute;
            left: 25%;
            right: calc(25% + 17px);
            height: 2px;
            background: rgba(180, 150, 50, 0.95);
            top: calc(50% - 2px);
            pointer-events: none;
            z-index: 10;
        }

        /* 3-Column Layout */
        #dump-binary {
            display: flex;
            flex-direction: row;
            min-height: 100%;
        }

        .col-addr,
        .col-hex,
        .col-ascii {
            display: flex;
            flex-direction: column;
        }

        .col-addr {
            width: 90px;
            min-width: 90px;
            flex-shrink: 0;
            border-right: 1px solid #333;
        }

        .col-hex {
            width: 440px;
            min-width: 440px;
            flex-shrink: 0;
            padding-left: 10px;
        }

        .col-ascii {
            flex-grow: 1;
            min-width: 100px;
            border-left: 1px solid #333;
            padding-left: 10px;
        }

        .dump-cell {
            height: 20px;
            min-height: 20px;
            line-height: 20px;
            font-size: 13px;
            white-space: pre;
        }

        .col-addr .dump-cell {
            color: #569cd6;
        }

        .col-hex .dump-cell {
            color: #ce9178;
            letter-spacing: 1px;
        }

        .col-ascii .dump-cell {
            color: #6a9955;
        }

        /* シート */
        .sheet-line {
            display: flex;
            font-size: 13px;
            line-height: 1.8;
            cursor: pointer;
            border-bottom: 1px solid #2d2d2d;
        }

        .sheet-line:hover {
            background: #2a2d2e;
        }

        .sheet-line.active {
            background: #444422;
            border-left: 3px solid #b4a032;
        }

        .sheet-line.non-ascii,
        .sheet-line.non-ascii .line-text,
        .sheet-line.non-ascii .line-num {
            color: #4ec9b0;
            cursor: text;
            user-select: text;
        }

        .line-num {
            color: #858585;
            min-width: 50px;
            text-align: right;
            padding-right: 12px;
            user-select: none;
        }

        .line-text {
            color: #d4d4d4;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .loading {
            color: #808080;
            font-style: italic;
        }

        footer {
            background: #333;
            padding: 4px 16px;
            font-size: 12px;
            color: #d4d4d4;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .footer-btn {
            background: #4ec9b0;
            color: #1e1e1e;
            border: none;
            padding: 2px 8px;
            font-size: 11px;
            cursor: pointer;
            border-radius: 3px;
            margin-left: 6px;
            font-family: inherit;
        }

        .footer-btn:hover {
            background: #3eb099;
        }

        #search-feedback {
            position: fixed;
            bottom: 40px;
            right: 20px;
            background: #2d2d2d;
            color: #eeeeee;
            padding: 12px 20px;
            font-size: 14px;
            z-index: 9999;
            border-radius: 4px;
            border-left: 5px solid #4ec9b0;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
            pointer-events: none;
            max-width: 350px;
            display: none;
            transition: all 0.2s ease;
        }

        #search-feedback.error {
            border-left-color: #f14c4c !important;
            background: #3a1e1e !important;
        }

        #search-feedback.warning {
            border-left-color: #f39c12 !important;
            background: #3a2e1e !important;
        }
    </style>
</head>

<body>
    <header>
        <h1>Binary Prompt Editor</h1>
        <div class="header-right-group">
            <span id="offset-display" style="color:#808080;font-size:12px;">Offset: 0x00000000</span>
            <span id="binary-info"
                style="color:#808080;font-size:12px;margin-left:16px;display:flex;align-items:center;">
                <span id="binary-filename" class="clickable-filename" onclick="selectBinaryFile()">Binary:
                    (loading...)</span>
                <button id="save-binary-btn" class="header-btn"
                    style="margin-left:8px;background:#ccc;border-color:#ccc;color:#888;cursor:not-allowed;" disabled
                    onclick="saveBinary()">Save</button>
            </span>
        </div>
    </header>

    <div class="container">
        <div class="panel panel-top">
            <div class="history-panel">
                <div class="panel-header">Operation History <span id="history-count" style="color:#808080;">(0)</span>
                </div>
                <div class="history-list" id="history-list"></div>
            </div>
            <div class="dict-panel">
                <div class="panel-header">
                    <button class="reload-btn" onclick="reloadServer()">Server Reload</button>
                </div>
                <div class="dict-content">
                    <div class="dict-editor-wrapper">
                        <div class="dict-overlay" id="dict-overlay" aria-hidden="true"></div>
                        <textarea class="dict-source" id="dict-textarea" spellcheck="false"></textarea>
                    </div>
                </div>
            </div>
            <div class="hex-area">
                <div class="panel-content" id="panel-top">
                    <div id="dump-binary" class="loading">Loading binary...</div>
                </div>
                <div class="minimap-wrapper">
                    <div class="minimap-cursor"></div>
                    <div class="minimap-container" id="minimap-container" tabindex="0">
                        <div id="padding-top" class="minimap-padding"></div>
                        <canvas id="minimap-canvas"></canvas>
                        <div id="padding-bottom" class="minimap-padding"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="panel-middle">
            <textarea id="search-input" class="search-box" placeholder="検索ワードを入力 (1024文字以上対応)..."
                maxlength="5000"></textarea>
            <button type="button" id="search-button" class="search-btn" title="検索" onclick="executeSearch()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                </svg>
            </button>
            <button id="edit-button" class="search-btn" title="編集">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                </svg>
            </button>
        </div>

        <div class="panel">
            <div class="panel-content" id="panel-bottom">
                <div class="panel-header" id="sheet-header-title">Sheet: system_prompts.md</div>
                <div id="sheet-content" class="loading">Loading sheet...</div>
            </div>
        </div>
    </div>

    <div id="search-feedback"></div>

    <footer id="footer-status">
        <span id="status-text">Initializing...</span>
        <div id="footer-actions">
            <input type="file" id="sheet-file-input" accept=".md,.txt,.csv" style="display:none;">
            <button class="footer-btn" id="btn-sheet-load" title="テキストファイルを読み込み">Load</button>
            <button class="footer-btn" id="btn-sheet-paste" title="クリップボードから貼り付け">Clip</button>
        </div>
    </footer>

    <script>
        // -------------------------------------------------------------------
        // グローバル変数
        // -------------------------------------------------------------------
        let CHUNK_SIZE = 8192;
        const PART_SIZE = 512;
        let totalBinarySize = 0;
        let currentBlockIndex = 0;
        let densityData = [];
        let isPartialLoaded = false;
        let lastTargetAddress = null;
        let loadedStartOffset = 0;
        let loadedEndOffset = 0;
        let isLoading = false;
        let maxW = 1.0;
        let currentHighlight = null;
        let currentDictionaryMatches = [];

        // 修正: 同値だった2定数を1つに統一
        const HIGHLIGHT_COLOR = 'rgba(100, 80, 10, 0.6)';

        let undoStack = [];
        let redoStack = [];
        let savedStackLength = 0;

        function updateSaveBtn() {
            const btn = document.getElementById('save-binary-btn');
            const fnSpan = document.getElementById('binary-filename');
            if (!btn) return;
            const isDirty = (undoStack.length !== savedStackLength);
            btn.disabled = !isDirty;
            if (isDirty) {
                btn.style.backgroundColor = '#4ec9b0';
                btn.style.borderColor = '#4ec9b0';
                btn.style.color = '#fff';
                btn.style.cursor = 'pointer';
                btn.style.animation = 'blink-save 1s ease-in-out infinite';
                if (fnSpan) fnSpan.style.opacity = '0.3';
            } else {
                btn.style.backgroundColor = '#ccc';
                btn.style.borderColor = '#ccc';
                btn.style.color = '#888';
                btn.style.cursor = 'not-allowed';
                btn.style.animation = 'none';
                if (fnSpan) fnSpan.style.opacity = '1';
            }
        }

        let activeSheetLine = -1;

        // Request control
        let lastRequestTime = 0;
        let debounceTimer = null;
        let pendingRequest = null;
        // 修正: AbortController を正しく使うため管理変数を維持
        let currentAbortController = null;

        function throttledLoadBinaryDump(offset, size) {
            const now = Date.now();
            const elapsed = now - lastRequestTime;
            pendingRequest = { offset, size };
            if (debounceTimer) { clearTimeout(debounceTimer); debounceTimer = null; }
            if (elapsed >= 100) {
                lastRequestTime = now;
                loadBinaryDump(offset, size);
            } else {
                debounceTimer = setTimeout(() => {
                    const req = pendingRequest;
                    if (req) {
                        lastRequestTime = Date.now();
                        loadBinaryDump(req.offset, req.size);
                        pendingRequest = null;
                    }
                    debounceTimer = null;
                }, 200);
            }
        }



        function densityToColor(density) {
            const w = density.w || 0;
            let red = 20, green = 20, blue = 20;
            if (w > 0 && maxW > 0) {
                const minGreen = 55;
                const range = 255 - minGreen;
                const norm = Math.min(1.0, w / maxW);
                green = minGreen + (norm * range);
            }
            return [Math.floor(Math.min(255, red)), Math.floor(Math.min(255, green)), Math.floor(Math.min(255, blue))];
        }

        function drawMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            const container = document.getElementById('minimap-container');
            const ctx = canvas.getContext('2d');
            const width = container.clientWidth - 17;
            const height = densityData.length;
            canvas.width = width;
            canvas.height = height;
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            for (let y = 0; y < densityData.length; y++) {
                const [r, g, b] = densityToColor(densityData[y]);
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    data[idx] = r; data[idx + 1] = g; data[idx + 2] = b; data[idx + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            const paddingHeight = getCursorOffset();
            document.getElementById('padding-top').style.height = paddingHeight + 'px';
            document.getElementById('padding-bottom').style.height = paddingHeight + 'px';
        }

        function getCursorOffset() {
            return Math.floor(document.getElementById('minimap-container').clientHeight / 2);
        }

        function getBlockAtCursor() {
            const container = document.getElementById('minimap-container');
            const scrollTop = container.scrollTop;
            const maxScrollTop = container.scrollHeight - container.clientHeight;
            if (maxScrollTop <= 0 || densityData.length === 0) return 0;
            return Math.floor((scrollTop / maxScrollTop) * (densityData.length - 1));
        }

        function scrollToBlock(blockIndex) {
            blockIndex = Math.max(0, Math.min(densityData.length - 1, blockIndex));
            const container = document.getElementById('minimap-container');
            const maxScrollTop = container.scrollHeight - container.clientHeight;
            if (densityData.length <= 1) { container.scrollTop = 0; return; }
            container.scrollTop = (blockIndex / (densityData.length - 1)) * maxScrollTop;
        }

        function onMinimapScroll() {
            const container = document.getElementById('minimap-container');
            if (densityData.length === 0) return;
            const blockIndex = getBlockAtCursor();
            const clampedIndex = Math.max(0, Math.min(densityData.length - 1, blockIndex));
            if (clampedIndex !== currentBlockIndex && !isLoading) {
                currentBlockIndex = clampedIndex;
                lastTargetAddress = null;
                throttledLoadBinaryDump(currentBlockIndex * CHUNK_SIZE, PART_SIZE);
            }
        }


        function onDumpScroll() {
            const container = document.getElementById('panel-top');
            const { scrollTop, scrollHeight, clientHeight } = container;
            if (scrollHeight - (scrollTop + clientHeight) < 100) {
                if (!isLoading && loadedEndOffset < totalBinarySize) {
                    loadBinaryDump(loadedEndOffset, PART_SIZE, true);
                }
            }
        }

        async function loadCurrentBlockFull() {
            if (isPartialLoaded && !isLoading && (loadedEndOffset - loadedStartOffset) < CHUNK_SIZE) {
                loadBinaryDump(loadedEndOffset, CHUNK_SIZE - (loadedEndOffset - loadedStartOffset), true);
            }
        }

        function showSearchFeedback(message, type = 'info') {
            const feedback = document.getElementById('search-feedback');
            if (!feedback) { alert(message); return; }
            feedback.textContent = message;
            feedback.style.display = 'block';
            feedback.style.opacity = '1';
            feedback.classList.remove('error', 'warning');
            if (type !== 'info') feedback.classList.add(type);
            if (window.feedbackTimer) clearTimeout(window.feedbackTimer);
            window.feedbackTimer = setTimeout(() => { feedback.style.display = 'none'; }, 8000);
        }

        let lastSearchQuery = "";
        let currentMatchIndex = 0;
        let cachedMatches = [];

        async function executeSearch(direction = 1) {
            const searchInput = document.getElementById('search-input');
            if (!searchInput) return;
            const searchText = searchInput.value.trim();
            if (!searchText) { showSearchFeedback("検索ワードを入力してください。", "warning"); return; }

            if (searchText === lastSearchQuery && cachedMatches.length > 0) {
                currentMatchIndex = (currentMatchIndex + direction + cachedMatches.length) % cachedMatches.length;
                const match = cachedMatches[currentMatchIndex];
                highlightRange(match.offset, match.length, HIGHLIGHT_COLOR);
                showSearchFeedback(`${currentMatchIndex + 1}/${cachedMatches.length} 件目: 0x${match.offset.toString(16).toUpperCase()} に移動`);
                return;
            }

            try {
                showSearchFeedback('Searching...', 'info');
                const res = await fetch(`/api/search?q=${encodeURIComponent(searchText)}`);
                const matches = await res.json();

                if (matches && matches.length > 0) {
                    cachedMatches = matches;
                    lastSearchQuery = searchText;
                    currentMatchIndex = 0;
                    const match = matches[0];
                    highlightRange(match.offset, match.length, HIGHLIGHT_COLOR);
                    if (matches.length === 1) {
                        showSearchFeedback(`1件ヒット: 0x${match.offset.toString(16).toUpperCase()}`);
                    } else {
                        showSearchFeedback(`${matches.length}件ヒット。1件目を表示中 (ボタン再押下で次へ)`, 'info');
                    }
                } else {
                    cachedMatches = [];
                    lastSearchQuery = searchText;
                    try {
                        const mapRes = await fetch(`/api/map-line?text=${encodeURIComponent(searchText)}`);
                        const mapData = await mapRes.json();
                        if (mapData.start_offset >= 0 && mapData.total_length > 0) {
                            highlightRange(mapData.start_offset, mapData.total_length, HIGHLIGHT_COLOR);
                            const addr = mapData.start_offset_hex;
                            if (mapData.binary_text) {
                                document.getElementById('search-input').value = mapData.binary_text;
                                updateEditButtonState();
                            }
                            showSearchFeedback(`${addr} に移動 (${mapData.total_length} bytes)`);
                        } else {
                            showSearchFeedback("バイナリ内に見つかりませんでした。", 'error');
                        }
                    } catch (mapErr) {
                        console.error("Map-line fallback failed:", mapErr);
                        showSearchFeedback("見つかりませんでした。", 'error');
                    }
                }
            } catch (err) {
                console.error("Search failed:", err);
                showSearchFeedback("検索エラー", 'error');
            }
        }
        window.executeSearch = executeSearch;

        function updateEditButtonState() {
            const editBtn = document.getElementById('edit-button');
            const searchInput = document.getElementById('search-input');
            if (!editBtn || !searchInput) return;
            const inputLen = searchInput.value.length;
            const highlightLen = currentHighlight ? currentHighlight.length : 0;
            if (highlightLen > 0 && inputLen === highlightLen) {
                editBtn.style.background = '#f39c12';
                editBtn.style.opacity = '1';
                editBtn.style.cursor = 'pointer';
                editBtn.title = `編集可能 (サイズ: ${highlightLen})`;
            } else {
                editBtn.style.background = '#444';
                editBtn.style.opacity = '0.5';
                editBtn.style.cursor = 'not-allowed';
                editBtn.title = `サイズ不一致 (入力: ${inputLen} / 選択: ${highlightLen})`;
            }
        }

        async function writeBinary(offset, bytes, description = '') {
            try {
                const res = await fetch('/api/write', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ offset, bytes }),
                });
                const data = await res.json();
                if (!data.ok) { showSearchFeedback(`書き込みエラー: ${data.error}`, 'error'); return false; }
                undoStack.push({ offset, original: data.original, description });
                redoStack = [];
                clearUndoneHistoryEntries();
                await loadBinaryDump(loadedStartOffset, PART_SIZE, false);
                if (currentHighlight) updateVisibleHighlights();
                updateSaveBtn();
                return true;
            } catch (err) {
                console.error('Write failed:', err);
                showSearchFeedback('書き込みエラー', 'error');
                return false;
            }
        }

        async function deleteSelection() {
            if (!currentHighlight || currentHighlight.length <= 0) {
                showSearchFeedback('範囲が選択されていません', 'warning'); return;
            }
            const { startAddr, length } = currentHighlight;
            const spaceBytes = new Array(length).fill(0x20);
            const lineInfo = activeSheetLine > 0 ? `L${activeSheetLine}` : '';
            const desc = `DEL ${lineInfo} 0x${startAddr.toString(16).toUpperCase()} (${length}B)`;
            const ok = await writeBinary(startAddr, spaceBytes, desc);
            if (ok) {
                addHistoryEntry('DEL', startAddr, length, activeSheetLine);
                showSearchFeedback(`${length} bytes を 0x20 で埋めました`);
            }
        }

        async function writeFromSearchBox() {
            if (!currentHighlight || currentHighlight.length <= 0) {
                showSearchFeedback('範囲が選択されていません', 'warning'); return;
            }
            const searchInput = document.getElementById('search-input');
            const text = searchInput.value;
            const textBytes = Array.from(new TextEncoder().encode(text));
            if (textBytes.length !== currentHighlight.length) {
                showSearchFeedback(`サイズ不一致 (入力: ${textBytes.length} / 選択: ${currentHighlight.length})`, 'warning');
                return;
            }
            const { startAddr, length } = currentHighlight;
            const lineInfo = activeSheetLine > 0 ? `L${activeSheetLine}` : '';
            const desc = `WRITE ${lineInfo} 0x${startAddr.toString(16).toUpperCase()} (${length}B)`;
            const ok = await writeBinary(startAddr, textBytes, desc);
            if (ok) {
                addHistoryEntry('WRITE', startAddr, length, activeSheetLine);
                showSearchFeedback(`${length} bytes を書き込みました`);
            }
        }

        // -------------------------------------------------------------------
        // Undo / Redo
        // -------------------------------------------------------------------
        async function undoLast() {
            if (undoStack.length === 0) { showSearchFeedback('Undo する操作がありません', 'warning'); return; }
            const last = undoStack.pop();
            try {
                const res = await fetch('/api/write', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ offset: last.offset, bytes: last.original }),
                });
                const data = await res.json();
                if (data.ok) {
                    redoStack.push({ offset: last.offset, newBytes: data.original, original: last.original, description: last.description });
                    await loadBinaryDump(loadedStartOffset, PART_SIZE, false);
                    if (currentHighlight) updateVisibleHighlights();
                    strikethroughLastEntry();
                    showSearchFeedback(`Undo: ${last.description}`);
                    updateSaveBtn();
                }
            } catch (err) {
                console.error('Undo failed:', err);
                showSearchFeedback('Undo エラー', 'error');
            }
        }

        async function redoLast() {
            if (redoStack.length === 0) { showSearchFeedback('Redo する操作がありません', 'warning'); return; }
            const last = redoStack.pop();
            try {
                const res = await fetch('/api/write', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ offset: last.offset, bytes: last.newBytes }),
                });
                const data = await res.json();
                if (data.ok) {
                    undoStack.push({ offset: last.offset, original: data.original, description: last.description });
                    await loadBinaryDump(loadedStartOffset, PART_SIZE, false);
                    if (currentHighlight) updateVisibleHighlights();
                    unstrikethroughLastEntry();
                    showSearchFeedback(`Redo: ${last.description}`);
                    updateSaveBtn();
                }
            } catch (err) {
                console.error('Redo failed:', err);
                showSearchFeedback('Redo エラー', 'error');
            }
        }

        // -------------------------------------------------------------------
        // 操作履歴パネル
        // -------------------------------------------------------------------
        function addHistoryEntry(action, offset, length, lineNum) {
            const list = document.getElementById('history-list');
            const countSpan = document.getElementById('history-count');
            const entry = document.createElement('div');
            entry.className = 'history-entry';
            const now = new Date();
            const time = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
            const lineStr = lineNum > 0 ? `<span class="h-line">L${lineNum}</span> ` : '';
            const actionClass = action === 'DEL' ? 'del' : '';
            const addr = `0x${offset.toString(16).toUpperCase().padStart(8, '0')}`;
            const unsavedLabel = undoStack.length !== savedStackLength
                ? `<span class="h-unsaved">unsaved</span>` : '';
            entry.innerHTML = `${lineStr}<span class="h-action ${actionClass}">${action}</span> <span class="h-addr">${addr}</span> ${length}B <span class="h-time">${time}</span>${unsavedLabel}`;
            entry.addEventListener('click', () => goToAddress(offset));
            list.appendChild(entry);
            list.scrollTop = list.scrollHeight;
            countSpan.textContent = list.children.length;
        }

        function strikethroughLastEntry() {
            const list = document.getElementById('history-list');
            const entries = list.querySelectorAll('.history-entry:not(.undone)');
            if (entries.length === 0) return;
            const entry = entries[entries.length - 1];
            entry.classList.add('undone');
            const existing = entry.querySelector('.h-saved, .h-unsaved');
            if (existing) existing.remove();
            const label = document.createElement('span');
            label.className = 'h-unsaved';
            label.textContent = 'unsaved';
            entry.appendChild(label);
            updateHistoryCount();
        }

        function unstrikethroughLastEntry() {
            const list = document.getElementById('history-list');
            const undone = list.querySelectorAll('.history-entry.undone');
            if (undone.length === 0) return;
            const entry = undone[undone.length - 1];
            entry.classList.remove('undone');
            const label = entry.querySelector('.h-unsaved');
            if (label) label.remove();
            updateHistoryCount();
        }

        function clearUndoneHistoryEntries() {
            const list = document.getElementById('history-list');
            list.querySelectorAll('.history-entry.undone').forEach(el => el.remove());
            updateHistoryCount();
        }

        function updateHistoryCount() {
            const list = document.getElementById('history-list');
            const countSpan = document.getElementById('history-count');
            const active = list.querySelectorAll('.history-entry:not(.undone)').length;
            const total = list.children.length;
            countSpan.textContent = active < total ? `${active}/${total}` : total;
        }

        function markHistorySaved() {
            const list = document.getElementById('history-list');
            list.querySelectorAll('.h-saved, .h-unsaved').forEach(el => el.remove());
            const entries = list.querySelectorAll('.history-entry:not(.undone)');
            if (entries.length === 0) return;
            const label = document.createElement('span');
            label.className = 'h-saved';
            label.textContent = 'saved';
            entries[entries.length - 1].appendChild(label);
        }

        // -------------------------------------------------------------------
        // イベント設定
        // -------------------------------------------------------------------
        function setupControls() {
            const container = document.getElementById('minimap-container');
            const wrapper = document.querySelector('.minimap-wrapper');
            const dumpContainer = document.getElementById('panel-top');
            const searchInput = document.getElementById('search-input');

            if (container) {
                container.addEventListener('scroll', onMinimapScroll);
                container.addEventListener('keydown', e => {
                    switch (e.key) {
                        case 'ArrowUp': e.preventDefault(); container.scrollTop -= 1; break;
                        case 'ArrowDown': e.preventDefault(); container.scrollTop += 1; break;
                        case 'PageUp': e.preventDefault(); container.scrollTop -= 4; break;
                        case 'PageDown': e.preventDefault(); container.scrollTop += 4; break;
                        case 'Home': e.preventDefault(); scrollToBlock(0); break;
                        case 'End': e.preventDefault(); scrollToBlock(densityData.length - 1); break;
                    }
                });
                container.addEventListener('focus', () => wrapper.classList.add('focused'));
                container.addEventListener('blur', () => wrapper.classList.remove('focused'));
            }

            if (dumpContainer) {
                dumpContainer.addEventListener('scroll', onDumpScroll);
                dumpContainer.addEventListener('mouseenter', loadCurrentBlockFull);
            }

            if (searchInput) {
                searchInput.addEventListener('keydown', e => {
                    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                        e.preventDefault();
                        executeSearch(e.shiftKey ? -1 : 1);
                    }
                });
                searchInput.addEventListener('input', updateEditButtonState);
            }

            const editBtn = document.getElementById('edit-button');
            if (editBtn) editBtn.addEventListener('click', writeFromSearchBox);

            document.addEventListener('keydown', e => {
                const inSearch = document.activeElement?.id === 'search-input';
                if (e.key === 'Delete' && !inSearch) {
                    e.preventDefault(); deleteSelection(); return;
                }
                if (!inSearch && ((e.key.toLowerCase() === 'z' && e.ctrlKey && e.shiftKey) ||
                    (e.key.toLowerCase() === 'y' && e.ctrlKey))) {
                    e.preventDefault(); redoLast(); return;
                }
                if (e.key.toLowerCase() === 'z' && (e.ctrlKey || e.metaKey) && !e.shiftKey && !inSearch) {
                    e.preventDefault(); undoLast();
                }
            });

            window.addEventListener('resize', drawMinimap);
            updateEditButtonState();
        }

        async function loadDensity() {
            try {
                const res = await fetch('/api/density');
                const data = await res.json();
                densityData = data.density;
                if (data.block_size) CHUNK_SIZE = data.block_size;
                if (data.max_density) maxW = data.max_density;
                drawMinimap();
            } catch (err) {
                console.error("Failed to load density:", err);
            }
        }

        function highlightRange(startAddr, length, color = HIGHLIGHT_COLOR) {
            currentHighlight = { startAddr, length, color };
            updateVisibleHighlights();
            updateEditButtonState();
            goToAddress(startAddr);
        }

        function updateVisibleHighlights() {
            const dumpContainer = document.getElementById('dump-binary');
            if (!dumpContainer) return;
            const colAddr = dumpContainer.querySelector('.col-addr');
            const colHex = dumpContainer.querySelector('.col-hex');
            const colAscii = dumpContainer.querySelector('.col-ascii');
            if (!colAddr || !colHex || !colAscii) return;

            const addrCells = colAddr.querySelectorAll('.dump-cell');
            const hexCells = colHex.querySelectorAll('.dump-cell');
            const asciiCells = colAscii.querySelectorAll('.dump-cell');

            addrCells.forEach((addrCell, idx) => {
                const lineAddr = parseInt(addrCell.textContent, 16);
                if (hexCells[idx]) {
                    hexCells[idx].querySelectorAll('span').forEach((sp, i) => {
                        const addr = lineAddr + i;
                        sp.style.background = isHighlighted(addr) || (isDictionaryMatch(addr) ? 'rgba(165,255,0,0.07)' : '');
                    });
                }
                if (asciiCells[idx]) {
                    asciiCells[idx].querySelectorAll('span').forEach((sp, i) => {
                        const addr = lineAddr + i;
                        sp.style.background = isHighlighted(addr) || (isDictionaryMatch(addr) ? 'rgba(165,255,0,0.07)' : '');
                    });
                }
            });
        }

        function isHighlighted(byteAddr) {
            if (!currentHighlight) return null;
            return (byteAddr >= currentHighlight.startAddr &&
                byteAddr < currentHighlight.startAddr + currentHighlight.length)
                ? currentHighlight.color : null;
        }

        function isDictionaryMatch(byteAddr) {
            return currentDictionaryMatches.some(m => byteAddr >= m.offset && byteAddr < m.offset + m.length);
        }

        async function goToAddress(addr) {
            if (addr >= loadedStartOffset && addr < loadedEndOffset) {
                scrollToAddressInView(addr);
                if (loadedEndOffset - addr < 512) loadBinaryDump(loadedEndOffset, PART_SIZE, true);
                return;
            }
            lastTargetAddress = addr;
            const blockIndex = Math.floor(addr / CHUNK_SIZE);
            currentBlockIndex = blockIndex;
            scrollToBlock(blockIndex);
            // 修正: loadOffset は addr を PART_SIZE 境界に切り捨てたアドレス
            const loadOffset = Math.floor(addr / PART_SIZE) * PART_SIZE;
            const loadSize = PART_SIZE * 2;
            await loadBinaryDump(loadOffset, loadSize, false);
            scrollToAddressInView(addr, loadedStartOffset);
        }

        function scrollToAddressInView(addr, baseOffset = null) {
            if (baseOffset === null) baseOffset = loadedStartOffset;
            const lineIndex = Math.floor((addr - baseOffset) / 16);
            const colAddr = document.getElementById('dump-binary')?.querySelector('.col-addr');
            if (colAddr) {
                const addrCells = colAddr.querySelectorAll('.dump-cell');
                if (addrCells[lineIndex]) addrCells[lineIndex].scrollIntoView({ behavior: 'auto', block: 'center' });
            }
        }

        async function loadBinaryDump(offset, size = CHUNK_SIZE, append = false) {
            if (isLoading) return 0;
            isLoading = true;
            currentAbortController = new AbortController();

            try {
                const res = await fetch(`/api/dump/${offset}/${size}`, { signal: currentAbortController.signal });
                const data = await res.json();
                const container = document.getElementById('dump-binary');

                let colAddr = container.querySelector('.col-addr');
                let colHex = container.querySelector('.col-hex');
                let colAscii = container.querySelector('.col-ascii');
                if (!colAddr) {
                    container.innerHTML = '';
                    colAddr = Object.assign(document.createElement('div'), { className: 'col-addr' });
                    colHex = Object.assign(document.createElement('div'), { className: 'col-hex' });
                    colAscii = Object.assign(document.createElement('div'), { className: 'col-ascii' });
                    container.append(colAddr, colHex, colAscii);
                }

                if (!append) {
                    colAddr.innerHTML = colHex.innerHTML = colAscii.innerHTML = '';
                    container.classList.remove('loading');
                    loadedStartOffset = offset;
                    currentDictionaryMatches = [];
                }
                if (data.matches) currentDictionaryMatches = currentDictionaryMatches.concat(data.matches);

                data.lines.forEach(line => {
                    const lineAddr = parseInt(line.addr, 16);

                    // Address
                    const addrDiv = Object.assign(document.createElement('div'), { className: 'dump-cell', textContent: line.addr });
                    colAddr.appendChild(addrDiv);

                    // Hex
                    const hexDiv = document.createElement('div');
                    hexDiv.className = 'dump-cell';
                    line.hex.split(' ').forEach((hex, i) => {
                        const sp = document.createElement('span');
                        sp.textContent = hex;
                        const charAddr = lineAddr + i;
                        const hl = isHighlighted(charAddr);
                        if (hl) sp.style.background = hl;
                        else if (isDictionaryMatch(charAddr)) sp.style.background = 'rgba(165,255,0,0.07)';
                        hexDiv.appendChild(sp);
                        if (i < 15) hexDiv.appendChild(document.createTextNode(' '));
                    });
                    colHex.appendChild(hexDiv);

                    // ASCII
                    const asciiDiv = document.createElement('div');
                    asciiDiv.className = 'dump-cell';
                    const hexBytes = line.hex.split(' ');
                    line.ascii.split('').forEach((char, i) => {
                        const sp = document.createElement('span');
                        sp.textContent = char;
                        const charAddr = lineAddr + i;
                        const hl = isHighlighted(charAddr);
                        if (hl) sp.style.background = hl;
                        else if (isDictionaryMatch(charAddr)) sp.style.background = 'rgba(165,255,0,0.07)';
                        if (hexBytes[i] === '2E') sp.style.color = '#dcdcaa';
                        asciiDiv.appendChild(sp);
                    });
                    colAscii.appendChild(asciiDiv);
                });

                totalBinarySize = data.total_size;
                loadedEndOffset = offset + data.lines.length * 16;
                isPartialLoaded = (loadedEndOffset - loadedStartOffset) < CHUNK_SIZE;
                updateOffsetDisplay(loadedStartOffset);
                if (!append && lastTargetAddress !== null) scrollToAddressInView(lastTargetAddress);
                isLoading = false;
                return data.total_size;
            } catch (err) {
                isLoading = false;
                if (err.name !== 'AbortError') console.error(err);
                return 0;
            }
        }


        function updateOffsetDisplay(offset) {
            const pct = (offset / totalBinarySize * 100).toFixed(1);
            const currentW = densityData[currentBlockIndex]?.w || 0;
            document.getElementById('offset-display').textContent =
                `0x${offset.toString(16).toUpperCase().padStart(8, '0')} - ` +
                `0x${loadedEndOffset.toString(16).toUpperCase().padStart(8, '0')} ` +
                `Block ${currentBlockIndex}/${densityData.length} ${pct}% Density:${currentW}`;
        }

        async function loadSheet() {
            try {
                const res = await fetch('/api/sheet');
                const data = await res.json();
                const container = document.getElementById('sheet-content');

                const sheetFilename = data.filename || 'system_prompts.md';
                const header = document.getElementById('sheet-header-title');
                if (header) header.textContent = `Sheet: ${sheetFilename}`;

                if (!data.lines) return 0;
                container.innerHTML = '';

                data.lines.forEach((line, idx) => {
                    const div = document.createElement('div');
                    const hasNonAscii = /[^\u0000-\u007F]/.test(line);
                    div.className = hasNonAscii ? 'sheet-line non-ascii' : 'sheet-line';

                    div.onclick = e => {
                        if (hasNonAscii) return;
                        const input = document.getElementById('search-input');
                        input.value = line.trim();
                        executeSearch();
                    };

                    const num = Object.assign(document.createElement('span'), { className: 'line-num', textContent: idx + 1 });
                    const text = Object.assign(document.createElement('span'), { className: 'line-text', textContent: line });
                    div.append(num, text);
                    container.appendChild(div);
                });
                return data.lines.length;
            } catch (e) {
                console.error(e);
                return 0;
            }
        }

        async function loadFileInfo() {
            try {
                const res = await fetch('/api/info');
                const data = await res.json();
                document.getElementById('binary-filename').textContent = `Binary: ${data.filename || 'none'}`;
            } catch (err) {
                console.error('loadFileInfo', err);
                document.getElementById('binary-filename').textContent = 'Binary: Error';
            }
        }

        async function selectBinaryFile() {
            const filenameSpan = document.getElementById('binary-filename');
            filenameSpan.textContent = 'Binary: (selecting...)';
            try {
                const res = await fetch('/api/select-binary', { method: 'POST' });
                const data = await res.json();
                if (data.ok) {
                    showSearchFeedback(`Binary loaded: ${data.filename}`, 'info');
                } else {
                    showSearchFeedback(`Failed to select binary: ${data.error}`, 'error');
                }
                location.reload();
            } catch (err) {
                showSearchFeedback(`Error: ${err.message}`, 'error');
                location.reload();
            }
        }

        async function loadDictWords() {
            try {
                const res = await fetch('/api/prompt-words');
                const data = await res.json();
                const ta = document.getElementById('dict-textarea');
                ta.value = data.words.join('\n');
            } catch (err) {
                console.error('loadDictWords', err);
            }
        }

        function getDictWordsFromUI() {
            const lines = document.getElementById('dict-textarea').value.split('\n');
            const words = [];
            let started = false;
            for (const line of lines) {
                if (!started && !line.trim()) continue;
                started = true;
                words.push(line);
            }
            return words;
        }

        async function saveDictWords() {
            const words = getDictWordsFromUI();
            try {
                const res = await fetch('/api/prompt-words', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ words }),
                });
                const data = await res.json();
                if (data.ok) console.log(`Saved ${data.count} prompt words`);
            } catch (err) {
                console.error('saveDictWords', err);
            }
        }

        async function reloadServer() {
            const btn = document.querySelector('.reload-btn');
            btn.textContent = 'Reloading...';
            btn.disabled = true;
            try {
                await saveDictWords();
                const res = await fetch('/api/reload', { method: 'POST' });
                const data = await res.json();
                if (data.ok) {
                    document.getElementById('binary-filename').textContent = `Binary: ${data.filename || 'none'}`;
                    await loadDensity();
                    await loadBinaryDump(currentBlockIndex * CHUNK_SIZE, PART_SIZE);
                    showSearchFeedback(`Reload complete: ${data.density_blocks} blocks, maxW:${data.max_density}`, 'info');
                    btn.classList.remove('dirty');
                    undoStack = []; redoStack = []; savedStackLength = 0;
                    updateSaveBtn();
                    document.getElementById('history-list').querySelectorAll('.h-saved, .h-unsaved').forEach(el => el.remove());
                }
            } catch (err) {
                console.error('reloadServer', err);
                showSearchFeedback(`Reload failed: ${err.message}`, 'error');
            } finally {
                btn.textContent = 'Server Reload';
                btn.disabled = false;
            }
        }

        async function init() {
            setupControls();

            // カスタムコピーハンドラ (Hex/ASCII列の改行除去)
            document.addEventListener('copy', e => {
                const selection = window.getSelection();
                if (selection.isCollapsed) return;
                const isTargetCol = node => {
                    if (!node) return false;
                    const elem = node.nodeType === 1 ? node : node.parentElement;
                    return elem && (elem.closest('.col-hex') || elem.closest('.col-ascii'));
                };
                const getClosest = (n, sel) => {
                    if (!n) return null;
                    const el = n.nodeType === 1 ? n : n.parentElement;
                    return el && el.closest(sel);
                };
                const isHex = getClosest(selection.anchorNode, '.col-hex') &&
                    getClosest(selection.focusNode, '.col-hex');
                if (isTargetCol(selection.anchorNode) && isTargetCol(selection.focusNode)) {
                    let text = selection.toString();
                    text = text.replace(/\n/g, isHex ? ' ' : '');
                    e.clipboardData.setData('text/plain', text);
                    e.preventDefault();
                }
            });

            const [binarySize] = await Promise.all([loadBinaryDump(0, PART_SIZE), loadSheet(), loadDensity()]);
            await loadFileInfo();
            await loadDictWords();

            // 辞書オーバーレイ同期
            const dictTextarea = document.getElementById('dict-textarea');
            const dictOverlay = document.getElementById('dict-overlay');
            const reloadBtn = document.querySelector('.reload-btn');

            if (dictTextarea && dictOverlay) {
                const updateOverlay = () => {
                    let text = dictTextarea.value;
                    text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    text = text.replace(/ /g, '<span class="space-mark"> </span>');
                    if (text.endsWith('\n')) text += '<br>';
                    dictOverlay.innerHTML = text;
                };
                dictTextarea.addEventListener('input', () => {
                    if (reloadBtn) { reloadBtn.classList.add('dirty'); reloadBtn.textContent = 'Save & Reload'; }
                    updateOverlay();
                });
                const syncScroll = () => {
                    dictOverlay.scrollTop = dictTextarea.scrollTop;
                    dictOverlay.scrollLeft = dictTextarea.scrollLeft;
                };
                dictTextarea.addEventListener('scroll', syncScroll);
                new ResizeObserver(syncScroll).observe(dictTextarea);
                updateOverlay();
            }

            // シートコントロール
            const sheetInput = document.getElementById('sheet-file-input');
            const loadBtn = document.getElementById('btn-sheet-load');
            const pasteBtn = document.getElementById('btn-sheet-paste');

            async function submitSheetUpdate(content, filename = null, isPaste = false) {
                try {
                    const res = await fetch('/api/sheet', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ content, filename, is_paste: isPaste }),
                    });
                    const data = await res.json();
                    if (data.ok) {
                        const fb = document.getElementById('search-feedback');
                        if (fb) { fb.textContent = `Updated: ${data.filename}`; fb.style.display = 'block'; setTimeout(() => fb.style.display = 'none', 3000); }
                        await loadSheet();
                        return data.filename;
                    } else {
                        alert(`Error: ${data.error}`);
                    }
                } catch (e) {
                    console.error('Update failed', e);
                    alert('Network Error');
                }
                return null;
            }

            if (loadBtn && sheetInput) {
                loadBtn.addEventListener('click', () => sheetInput.click());
                sheetInput.addEventListener('change', e => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = async ev => {
                        if (confirm(`Load content from ${file.name}?`)) {
                            const newName = await submitSheetUpdate(ev.target.result, file.name, false);
                            if (newName) { loadBtn.textContent = newName; loadBtn.style.color = '#fff'; }
                        }
                    };
                    reader.readAsText(file);
                    sheetInput.value = '';
                });
            }

            if (pasteBtn) {
                pasteBtn.addEventListener('click', async () => {
                    try {
                        const text = await navigator.clipboard.readText();
                        if (text && confirm('Import from clipboard?')) {
                            const newName = await submitSheetUpdate(text, null, true);
                            if (newName) { loadBtn.textContent = newName; loadBtn.style.color = '#fff'; }
                        }
                    } catch (err) {
                        alert('Clipboard access failed');
                    }
                });
            }

            document.getElementById('status-text').textContent =
                `Binary: ${(binarySize / 1024 / 1024).toFixed(2)} MB  Cursor: 1block  PgUp/Dn: 4blocks`;
        }

        // Save Binary
        window.saveBinary = async function (save_as_bin = false) {
            const confirmMsg = save_as_bin
                ? '同じディレクトリに .bin ファイルとして保存します。続行しますか？'
                : '上書き保存します。.bak バックアップが作成されます。続行しますか？';
            if (!confirm(confirmMsg)) return;
            const btn = document.getElementById('save-binary-btn');
            if (btn) { btn.disabled = true; btn.innerText = 'Saving...'; }
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                const res = await fetch('/api/save-binary', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ save_as_bin }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                const data = await res.json();
                if (data.ok) {
                    savedStackLength = undoStack.length;
                    updateSaveBtn();
                    markHistorySaved();
                    let msg = `✅ 保存完了:\n${data.path.split(/[\\/]/).pop()}`;
                    if (data.backup) {
                        const bakName = data.backup.split(/[\\/]/).pop();
                        const highlighted = bakName.replace(/(\.bak-\d+)$/, '【$1】');
                        msg += `\n\n📁 バックアップ作成:\n${highlighted}`;
                    }
                    alert(msg);
                } else {
                    if (data.error && data.error.includes('Permission denied')) {
                        const retry = confirm(
                            `保存失敗: ファイルが使用中です。\nゲームを終了してから保存することをお勧めします。\n\n` +
                            `代わりに同じディレクトリに .bin ファイルとして保存しますか？`
                        );
                        if (retry) await saveBinary(true);
                    } else {
                        alert(`Error: ${data.error}`);
                    }
                }
            } catch (err) {
                console.error(err);
                if (err.name === 'AbortError') alert('保存タイムアウト');
                else alert(`保存エラー: ${err.message}`);
            } finally {
                if (btn) { btn.innerText = 'Save'; updateSaveBtn(); }
            }
        };
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>

</html>